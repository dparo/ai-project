:source-highlighter: coderay

= Hello, AsciiDoc

Doc Writer <doc@example.com>

An introduction to
http://asciidoc.org[AsciiDoc]








== First Section
* item1
* item2
** item3



.main.c
[source,c,linenums]
----
bool
ast_build_from_command( struct interpreter *intpt,
                        char *commandline, size_t commandline_len )
{
    struct ast *ast = & intpt->ast;
    ast_clear(ast);

    // Insure null-termination, It is not strictly necessary
    // i think, but it may require further testing
    assert(commandline[commandline_len] == 0);


#define SHUNTING_YARD_DEBUG 1
    
#if SHUNTING_YARD_DEBUG == 1
#define SHUNT_DBG() do { token_stack_dbglog( & stack ); ast_dbglog( ast ); printf("\n"); } while(0);
#else
#define SHUNT_DBG() do { } while(0)
#endif
    
    Token token = Empty_Token;
    bool done = false;
    Tokenizer tknzr;
    tokenizer_init_from_memory( &tknzr, commandline,
                                commandline_len,
                                "*commandline*");

    // https://en.wikipedia.org/wiki/Shunting-yard_algorithm

    // operator stack
    static struct token_stack stack;
    stack.num_tokens = 0;
    bool prev_was_identifier = false;

    // NOTE: Maybe better error handling because even the push_state can throw an error
    //       Maybe set a locked variable inside the tokenizer for critical stuff
    //       that will inevitably inject more complexity on the library side
    while (!done && get_next_token( &tknzr, & token)) {
        SHUNT_DBG();
        // NOTE: At every iteration the tokenizer error is cleared with the call to get_next_token
        if ( tknzr.err ) {
            puts(tknzr.err_desc);
            assert_msg(0, "We got an error boys");
        }    


        if ( prev_was_identifier ) {
            if ( token.type ==  TT_PUNCT_OPEN_PAREN ) {
                token.type = TT_PUNCT_META_FNCALL;
            } else if (token.type == TT_PUNCT_OPEN_BRACKET ) {
                token.type = TT_PUNCT_META_INDEX;
            } else if ( token.type == TT_PUNCT_OPEN_BRACE ) {
                token.type = TT_PUNCT_META_COMPOUND;
            }
        }
        
        // log_token(& token);



        
        // Extensions ->
        //   Postfix operators do an uncoditional push onto
        //                 ast_token_queue_push(queue, &token)
        // 
        // Prefix operators do an uncoditional push onto    ???(Needs testing)???
        //                   ast_token_stack_push(&stack, &token);
        
        // Shunting-yard algorithm
        // @NOTE: Does not handle functions
        {
            if (token.type == TT_CONSTANT ||
                token.type == TT_IDENTIFIER ) {
                if ( token.type == TT_IDENTIFIER ) {
                    prev_was_identifier = true;
                }
                token_stack_push( & stack, & token);
                // ast_push(ast, &token);
            } /* else if ( is function ) */
            else {
                if ( token.type == TT_PUNCT_OPEN_PAREN ) {
                    token_stack_push( & stack, & token);
                } else if ( token.type == TT_PUNCT_CLOSE_PAREN
                            || token.type == TT_PUNCT_CLOSE_BRACE
                            || token.type == TT_PUNCT_CLOSE_BRACKET) {
                    Token *peek = NULL;
                    while ((stack.num_tokens != 0) && (peek = token_stack_peek_addr(&stack))) {
                        if ( peek->type != TT_PUNCT_OPEN_PAREN ) {
                            ast_push(ast, peek);
                            token_stack_pop( & stack);
                        } else { break; }
                    }
                    if ( stack.num_tokens == 0 ) {
                        if ( peek && peek->type != TT_PUNCT_OPEN_PAREN ) {
                            // Mismatched parentheses
                            intpt_info_printf(intpt, "Mismatched parens\n");
                            goto parse_end;
                        }
                    } else {
                        // pop the open paren from the stack
                        if ( peek && peek->type == TT_PUNCT_OPEN_PAREN )
                            token_stack_pop( & stack );
                    }
                } else if ( token_is_operator(& token)) {
                    bool ispostfix = is_postfix_operator( &token);
                    Token *peek = NULL;
                    while ((stack.num_tokens != 0) && (peek = token_stack_peek_addr(&stack))) {
                        if ( !(peek->type == TT_PUNCT_OPEN_PAREN)
                             && ( (peek->type == TT_IDENTIFIER || peek->type == TT_CONSTANT)
                                  || (op_greater_precedence(peek, & token))
                                  || ((op_eq_precedence(peek, &token)) && (op_is_left_associative(peek))))) {
                            ast_push(ast, peek);
                            token_stack_pop( & stack);
                        } else { break; }
                    }
                    if ( ispostfix ) {
                        ast_push(ast, & token);
                    } else {
                        token_stack_push( & stack, & token);
                    }
                } else {
                    invalid_code_path();
                }

                if ( prev_was_identifier && token.type == TT_PUNCT_META_FNCALL ) {
                    token.type = TT_PUNCT_OPEN_PAREN;
                    token_stack_push( & stack, & token);
                }

                if ( token.type == TT_PUNCT_OPEN_BRACE || token.type == TT_PUNCT_OPEN_BRACKET
                     || token.type == TT_PUNCT_META_INDEX || token.type == TT_PUNCT_META_COMPOUND) {
                    token.type = TT_PUNCT_OPEN_PAREN;
                    token_stack_push ( & stack, & token );
                }
                
                prev_was_identifier = false;
            }
        }
    }

#if SHUNTING_YARD_DEBUG == 1
    printf("Out of main loop: \n");
#endif

    /* if there are no more tokens to read: */
    /* 	while there are still operator tokens on the stack: */
    /* 		/\* if the operator token on the top of the stack is a bracket, then there are mismatched parentheses. *\/ */
    /* 		pop the operator from the operator stack onto the output queue. */

    Token *peek = NULL;
    while ( ( (stack.num_tokens) != 0 && (peek = token_stack_peek_addr(&stack)))) {
        SHUNT_DBG();
        if ( peek->type == TT_PUNCT_OPEN_PAREN || peek->type == TT_PUNCT_CLOSE_PAREN
             || peek->type == TT_PUNCT_CLOSE_BRACE
             || peek->type == TT_PUNCT_CLOSE_BRACKET ) {
            intpt_info_printf( intpt, " ### Mismatched parens\n");
            goto parse_end;
        }
        ast_push( ast, peek );
        token_stack_pop ( & stack );
    }

#if SHUNTING_YARD_DEBUG == 1
    printf("Final: ");
    SHUNT_DBG();
#endif
    
    token_stack_dbglog( & stack );
    ast_dbglog( ast );
    printf("\n");

    return true;
    
parse_end: {
        intpt_info_printf(intpt, " ### Failed formula parsing\n");
        return false;
    }
}
----
