<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Hello, AsciiDoc</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme"><style>/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}</style><link href="reveal.js/lib/css/zenburn.css" rel="stylesheet"><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js/css/print/pdf.css" : "reveal.js/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="reveal.js/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Hello, AsciiDoc</h1><div class="preamble"><div class="paragraph"><p>Doc Writer &lt;<a href="mailto:doc@example.com">doc@example.com</a>&gt;</p></div>
<div class="paragraph"><p>An introduction to
<a href="http://asciidoc.org">AsciiDoc</a></p></div></div></section>
<section id="first_section"><h2>First Section</h2><div class="ulist"><ul><li><p>item1</p></li><li><p>item2</p><div class="ulist"><ul><li><p>item3</p></li></ul></div></li></ul></div>
<div class="listingblock"><div class="title">main.c</div><div class="content"><pre class="CodeRay"><code class="c language-c"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
</pre></td>
  <td class="code"><pre><span class="predefined-type">bool</span>
ast_build_from_command( <span class="keyword">struct</span> interpreter *intpt,
                        <span class="predefined-type">char</span> *commandline, size_t commandline_len )
{
    <span class="keyword">struct</span> ast *ast = &amp; intpt-&gt;ast;
    ast_clear(ast);

    <span class="comment">// Insure null-termination, It is not strictly necessary</span>
    <span class="comment">// i think, but it may require further testing</span>
    assert(commandline[commandline_len] == <span class="integer">0</span>);


<span class="preprocessor">#define</span> SHUNTING_YARD_DEBUG <span class="integer">1</span>

<span class="preprocessor">#if</span> SHUNTING_YARD_DEBUG == <span class="integer">1</span>
<span class="preprocessor">#define</span> SHUNT_DBG() <span class="keyword">do</span> { token_stack_dbglog( &amp; stack ); ast_dbglog( ast ); printf(<span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>); } <span class="keyword">while</span>(<span class="integer">0</span>);
<span class="preprocessor">#else</span>
<span class="preprocessor">#define</span> SHUNT_DBG() <span class="keyword">do</span> { } <span class="keyword">while</span>(<span class="integer">0</span>)
<span class="preprocessor">#endif</span>

    Token token = Empty_Token;
    <span class="predefined-type">bool</span> done = <span class="predefined-constant">false</span>;
    Tokenizer tknzr;
    tokenizer_init_from_memory( &amp;tknzr, commandline,
                                commandline_len,
                                <span class="string"><span class="delimiter">&quot;</span><span class="content">*commandline*</span><span class="delimiter">&quot;</span></span>);

    <span class="comment">// https://en.wikipedia.org/wiki/Shunting-yard_algorithm</span>

    <span class="comment">// operator stack</span>
    <span class="directive">static</span> <span class="keyword">struct</span> token_stack stack;
    stack.num_tokens = <span class="integer">0</span>;
    <span class="predefined-type">bool</span> prev_was_identifier = <span class="predefined-constant">false</span>;

    <span class="comment">// NOTE: Maybe better error handling because even the push_state can throw an error</span>
    <span class="comment">//       Maybe set a locked variable inside the tokenizer for critical stuff</span>
    <span class="comment">//       that will inevitably inject more complexity on the library side</span>
    <span class="keyword">while</span> (!done &amp;&amp; get_next_token( &amp;tknzr, &amp; token)) {
        SHUNT_DBG();
        <span class="comment">// NOTE: At every iteration the tokenizer error is cleared with the call to get_next_token</span>
        <span class="keyword">if</span> ( tknzr.err ) {
            puts(tknzr.err_desc);
            assert_msg(<span class="integer">0</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">We got an error boys</span><span class="delimiter">&quot;</span></span>);
        }


        <span class="keyword">if</span> ( prev_was_identifier ) {
            <span class="keyword">if</span> ( token.type ==  TT_PUNCT_OPEN_PAREN ) {
                token.type = TT_PUNCT_META_FNCALL;
            } <span class="keyword">else</span> <span class="keyword">if</span> (token.type == TT_PUNCT_OPEN_BRACKET ) {
                token.type = TT_PUNCT_META_INDEX;
            } <span class="keyword">else</span> <span class="keyword">if</span> ( token.type == TT_PUNCT_OPEN_BRACE ) {
                token.type = TT_PUNCT_META_COMPOUND;
            }
        }

        <span class="comment">// log_token(&amp; token);</span>




        <span class="comment">// Extensions -&gt;</span>
        <span class="comment">//   Postfix operators do an uncoditional push onto</span>
        <span class="comment">//                 ast_token_queue_push(queue, &amp;token)</span>
        <span class="comment">//</span>
        <span class="comment">// Prefix operators do an uncoditional push onto    ???(Needs testing)???</span>
        <span class="comment">//                   ast_token_stack_push(&amp;stack, &amp;token);</span>

        <span class="comment">// Shunting-yard algorithm</span>
        <span class="comment">// @NOTE: Does not handle functions</span>
        {
            <span class="keyword">if</span> (token.type == TT_CONSTANT ||
                token.type == TT_IDENTIFIER ) {
                <span class="keyword">if</span> ( token.type == TT_IDENTIFIER ) {
                    prev_was_identifier = <span class="predefined-constant">true</span>;
                }
                token_stack_push( &amp; stack, &amp; token);
                <span class="comment">// ast_push(ast, &amp;token);</span>
            } <span class="comment">/* else if ( is function ) */</span>
            <span class="keyword">else</span> {
                <span class="keyword">if</span> ( token.type == TT_PUNCT_OPEN_PAREN ) {
                    token_stack_push( &amp; stack, &amp; token);
                } <span class="keyword">else</span> <span class="keyword">if</span> ( token.type == TT_PUNCT_CLOSE_PAREN
                            || token.type == TT_PUNCT_CLOSE_BRACE
                            || token.type == TT_PUNCT_CLOSE_BRACKET) {
                    Token *peek = <span class="predefined-constant">NULL</span>;
                    <span class="keyword">while</span> ((stack.num_tokens != <span class="integer">0</span>) &amp;&amp; (peek = token_stack_peek_addr(&amp;stack))) {
                        <span class="keyword">if</span> ( peek-&gt;type != TT_PUNCT_OPEN_PAREN ) {
                            ast_push(ast, peek);
                            token_stack_pop( &amp; stack);
                        } <span class="keyword">else</span> { <span class="keyword">break</span>; }
                    }
                    <span class="keyword">if</span> ( stack.num_tokens == <span class="integer">0</span> ) {
                        <span class="keyword">if</span> ( peek &amp;&amp; peek-&gt;type != TT_PUNCT_OPEN_PAREN ) {
                            <span class="comment">// Mismatched parentheses</span>
                            intpt_info_printf(intpt, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mismatched parens</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
                            <span class="keyword">goto</span> parse_end;
                        }
                    } <span class="keyword">else</span> {
                        <span class="comment">// pop the open paren from the stack</span>
                        <span class="keyword">if</span> ( peek &amp;&amp; peek-&gt;type == TT_PUNCT_OPEN_PAREN )
                            token_stack_pop( &amp; stack );
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> ( token_is_operator(&amp; token)) {
                    <span class="predefined-type">bool</span> ispostfix = is_postfix_operator( &amp;token);
                    Token *peek = <span class="predefined-constant">NULL</span>;
                    <span class="keyword">while</span> ((stack.num_tokens != <span class="integer">0</span>) &amp;&amp; (peek = token_stack_peek_addr(&amp;stack))) {
                        <span class="keyword">if</span> ( !(peek-&gt;type == TT_PUNCT_OPEN_PAREN)
                             &amp;&amp; ( (peek-&gt;type == TT_IDENTIFIER || peek-&gt;type == TT_CONSTANT)
                                  || (op_greater_precedence(peek, &amp; token))
                                  || ((op_eq_precedence(peek, &amp;token)) &amp;&amp; (op_is_left_associative(peek))))) {
                            ast_push(ast, peek);
                            token_stack_pop( &amp; stack);
                        } <span class="keyword">else</span> { <span class="keyword">break</span>; }
                    }
                    <span class="keyword">if</span> ( ispostfix ) {
                        ast_push(ast, &amp; token);
                    } <span class="keyword">else</span> {
                        token_stack_push( &amp; stack, &amp; token);
                    }
                } <span class="keyword">else</span> {
                    invalid_code_path();
                }

                <span class="keyword">if</span> ( prev_was_identifier &amp;&amp; token.type == TT_PUNCT_META_FNCALL ) {
                    token.type = TT_PUNCT_OPEN_PAREN;
                    token_stack_push( &amp; stack, &amp; token);
                }

                <span class="keyword">if</span> ( token.type == TT_PUNCT_OPEN_BRACE || token.type == TT_PUNCT_OPEN_BRACKET
                     || token.type == TT_PUNCT_META_INDEX || token.type == TT_PUNCT_META_COMPOUND) {
                    token.type = TT_PUNCT_OPEN_PAREN;
                    token_stack_push ( &amp; stack, &amp; token );
                }

                prev_was_identifier = <span class="predefined-constant">false</span>;
            }
        }
    }

<span class="preprocessor">#if</span> SHUNTING_YARD_DEBUG == <span class="integer">1</span>
    printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Out of main loop: </span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
<span class="preprocessor">#endif</span>

    <span class="comment">/* if there are no more tokens to read: */</span>
    <span class="comment">/*         while there are still operator tokens on the stack: */</span>
    <span class="comment">/*                 /\* if the operator token on the top of the stack is a bracket, then there are mismatched parentheses. *\/ */</span>
    <span class="comment">/*                 pop the operator from the operator stack onto the output queue. */</span>

    Token *peek = <span class="predefined-constant">NULL</span>;
    <span class="keyword">while</span> ( ( (stack.num_tokens) != <span class="integer">0</span> &amp;&amp; (peek = token_stack_peek_addr(&amp;stack)))) {
        SHUNT_DBG();
        <span class="keyword">if</span> ( peek-&gt;type == TT_PUNCT_OPEN_PAREN || peek-&gt;type == TT_PUNCT_CLOSE_PAREN
             || peek-&gt;type == TT_PUNCT_CLOSE_BRACE
             || peek-&gt;type == TT_PUNCT_CLOSE_BRACKET ) {
            intpt_info_printf( intpt, <span class="string"><span class="delimiter">&quot;</span><span class="content"> ### Mismatched parens</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">goto</span> parse_end;
        }
        ast_push( ast, peek );
        token_stack_pop ( &amp; stack );
    }

<span class="preprocessor">#if</span> SHUNTING_YARD_DEBUG == <span class="integer">1</span>
    printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">Final: </span><span class="delimiter">&quot;</span></span>);
    SHUNT_DBG();
<span class="preprocessor">#endif</span>

    token_stack_dbglog( &amp; stack );
    ast_dbglog( ast );
    printf(<span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;

<span class="label">parse_end:</span> {
        intpt_info_printf(intpt, <span class="string"><span class="delimiter">&quot;</span><span class="content"> ### Failed formula parsing</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}</pre></td>
</tr></table></code></pre></div></div></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script>// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: true,
  // Display a presentation progress bar
  progress: true,
  // Set a per-slide timing for speaker notes, null means none
  defaultTiming: null,
  // Display the page number of the current slide
  slideNumber: false,
  // Push each slide change to the browser history
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, black, league, night, serif, simple, sky, solarized, white)
  // NOTE setting the theme in the config no longer works in reveal.js 3.x
  //theme: Reveal.getQueryHash().theme || 'black',
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: Reveal.getQueryHash().transition || 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js/plugin/notes/notes.js', async: true }
  ]
});</script></body></html>