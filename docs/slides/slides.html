<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Davide Paro" />
  <title>A SAT Solver Implementation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="./Slidy2/styles/slidy.css" />
  <script src="./Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">A SAT Solver Implementation</h1>
  <p class="author">
Davide Paro
  </p>
  <p class="date">May 2018</p>
</div>
<div id="parsing" class="slide section level1">
<h1>Parsing</h1>
<ol style="list-style-type: decimal">
<li><p>Il primo passo consiste nella <strong>tokenizzazione</strong> della formula. Ogni singolo carattere viene raggruppato in &quot;tokens&quot; secondo le regole sintattiche definite dal linguaggio.</p></li>
<li><p>Una volta generati i &quot;tokens&quot;, si procede alla conversione della formula dalla forma <strong>infissa</strong> (piu' comoda agli umani) in una forma <strong>prefissa</strong> (LISP Notation).</p>
<pre><code>  (A &amp; B) | C     --&gt;    (| (&amp; A B) C)</code></pre></li>
<li><p>Si fa uso dell'algoritmo <strong>Shunting-Yard</strong> fortemente customizzato con estensioni per risolvere il problema in questione. In base a regole di precedenza degli operatori e alle regole sintattiche definite per il linguaggio verra' generata la notazione prefissa appropriata.</p></li>
</ol>
</div>
<div id="ast-generation" class="slide section level1">
<h1>AST Generation</h1>
<ol style="list-style-type: decimal">
<li>Una volta &quot;parsata&quot; la formula in forma prefissa si genera l'albero di sintassi &lt;<strong>AST</strong>&gt;. L'albero di sintassi verra' implementato semplicemente con un semplice STACK.</li>
<li><p>Segue un analisi semantica e di validita' della formula presente nell'AST. Se erronea, viene rifiutata.</p>
<pre><code>  A &amp; | B   e&#39; una formula mal formata -&gt; errore</code></pre></li>
<li><p>Una volta verificata la validita' della formula se ne estraggono i vari simboli/letterali/identificatori e si usano per costruire una <strong>Symbol Table</strong>. (Esattamente come un compilatore)</p>
<pre><code>  FORMULA:      (| (&amp; A B) C) </code></pre>
<div class="figure">
<img src="imgs/generated_ast.png" />

</div></li>
</ol>
</div>
<div id="bruteforce-solver-bf" class="slide section level1">
<h1>BruteForce Solver (BF)</h1>
<blockquote>
<p>Genera una truth table</p>
</blockquote>
<ol style="list-style-type: decimal">
<li>In base al numero di letterali trovati all'interno della formula si procede alla generazione di 2^n possibili combinazioni (dove n e' il numero di letterali)</li>
<li><p>Grazie al fatto di aver rappresentato l'AST con un semplice stack ci permette di implementare un risolutore che sostanzialmente lavora come una <strong>stack-virtual-machine</strong>. Si procede dal fondo dello stack per ogni letterale/costante si &quot;pusha&quot; il valore in un altro stack <strong>(Virtual Machine Stack)</strong> e per ogni operatore si fa il &quot;pop&quot; del numero necessario di operandi e si &quot;ripusha&quot; il risultato. Alla fine della &quot;evaluation&quot; dell'intero AST in caso di formula ben formata sullo stack delle computazioni rimane solamente un elemento: il risultato della computazione dell'intera formula.</p>
<pre><code>FORMULA:      (| (&amp; A B) C)
ASSEGNAMENTO: [A = 0, B = 1, C = 1]</code></pre></li>
</ol>
<div class="figure">
<img src="imgs/ast_stack.gif" />

</div>
<p>{{ DEMO }}</p>
</div>
<div id="bf-performance-analysis" class="slide section level1">
<h1>BF: Performance Analysis</h1>
<ul>
<li><p>Un risolutore basato su bruteforce comincia a diventare impraticabile gia' con 16 letterali.</p>
<pre><code>  Esempio: &quot;a1 | a2 | .... | an&quot;</code></pre></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">N: Numero letterali</th>
<th align="left">Tempo di computazione</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">15</td>
<td align="left">6 secondi</td>
</tr>
<tr class="even">
<td align="left">16</td>
<td align="left">12 secondi</td>
</tr>
<tr class="odd">
<td align="left">17</td>
<td align="left">27 secondi</td>
</tr>
<tr class="even">
<td align="left">18</td>
<td align="left">57 secondi</td>
</tr>
<tr class="odd">
<td align="left">19</td>
<td align="left">121 secondi</td>
</tr>
</tbody>
</table>
<ul>
<li>Il tempo di computazione diventa piu' del doppio per ogni letterale</li>
<li><p>Il tempo di computazione peggiora ulteriormente se sono presenti sotto-formule coincidenti. Esse vengono valutate piu' volte dal risolutore</p></li>
<li><p>Inoltre quando il numero di letterali inizia ad essere consistente l'output generato da Bruteforce risulta pressoche' inutilizzabile.</p></li>
</ul>
<p><a href="./imgs/bruteforce_unusable_output.html" target="_blank"><strong>Bruteforce Unusable Output</strong></a></p>
</div>
<div id="a-better-approach" class="slide section level1">
<h1>A Better Approach</h1>
<ul>
<li>Se ci interessa solamente dimostrare la soddisfacibilita' di una formula logica si puo' utilizzare un algoritmo che fa uso di backtracking.</li>
<li><strong>SODDISFACIBILITA'</strong>: Si vuole dimostarre se la formula presenta almeno un <strong>interpretazione</strong> (un particolare assegnamento per i letterali) che rende la formula <em>vera</em>.</li>
<li><strong>INSODDISFACIBILITA'</strong>: Si vuole dimostrare che indipendentemente dall'assegnamento dei letterali la formula risulta sempre <em>falsa</em>.</li>
<li><strong>VALIDITA' DI UNA TESI</strong>: Equivale a dimostrare che la tesi negata risulta insoddisfacibile. (Dimostrazione per assurdo)</li>
</ul>
</div>
<div id="dpll-algorithm" class="slide section level1">
<h1>DPLL Algorithm</h1>
<ul>
<li>Introdotto nel 1962 da Martin Davis, George Logemann, Donald W. Loveland</li>
<li><p>Algoritmo classico, e usato come base per algoritmi migliori che si sono evoluti da DPLL. Esempio:</p>
<pre><code>Chaff, zChaff, GRASP</code></pre></li>
</ul>
<p>Sono delle implementazioni piu' performanti e raffinate di <strong>DPLL</strong></p>
<p><a href="https://en.wikipedia.org/wiki/DPLL_algorithm"><strong>Wikipedia Link</strong></a></p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby">     <span class="dt">Algorithm</span> <span class="dt">DPLL</span>
       <span class="dt">Input</span>: A set of clauses K.
       <span class="dt">Output</span>: A <span class="dt">Truth</span> <span class="dt">Value</span>.
     ----------------------------------------------
     function <span class="dt">DPLL</span>(K) {
        <span class="kw">if</span> K is a consistent set of literals
            <span class="kw">then</span> <span class="kw">return</span> <span class="dv">true</span>;
        <span class="kw">if</span> K contains an empty clause
            <span class="kw">then</span> <span class="kw">return</span> <span class="dv">false</span>;
        <span class="kw">for</span> every unit clause {l} <span class="kw">in</span> K
           K ← unit-propagate(l, K);
        <span class="kw">for</span> every literal l that occurs pure <span class="kw">in</span> K
           K ← pure-literal-assign(l, K);
        l ← choose-literal(K);
        <span class="kw">return</span> <span class="dt">DPLL</span>(K <span class="kw">and</span> {l}) <span class="kw">or</span> <span class="dt">DPLL</span>(K <span class="kw">and</span> {<span class="kw">not</span>(l)});
     }</code></pre></div>
</div>
<div id="cnf-conversion" class="slide section level1">
<h1>CNF Conversion</h1>
<ol style="list-style-type: decimal">
<li><p>Si trasformano tutti gli operatori come funzioni di solamente <strong>AND, OR, NOT</strong></p>
<pre><code>a ^ b     =   (!a | !b) &amp; (a | b)
a -&gt; b    =   !a | b
a &lt;-&gt; b   =   !(a ^ b)  =  !((!a | !b) &amp; (a | b))</code></pre></li>
</ol>
<p>Dalla teoria sappiamo che qualsiasi circuito/formula-logica puo' essere sintetizzata solamente con la combinazione di AND, OR, NOT.</p>
<pre><code>   Esempio: A &lt;-&gt; B
   </code></pre>
<div class="figure">
<img src="imgs/formula_op_conv.png" />

</div>
<ol start="2" style="list-style-type: decimal">
<li><p>Si applica De-Morgan ricorsivamente in modo da &quot;spingere le negazioni in basso&quot;. Alla fine dell'applicazione di De-Morgan si avra' una formula dipendentemente da</p>
<pre><code>a1, a2, ...., an, !a1, !a2, ...., !an</code></pre></li>
</ol>
<p>In cui le negazioni compaiono solamente precedendo gli input e non &quot;in mezzo alla formula&quot;</p>
<div class="figure">
<img src="imgs/formula_demorgan.png" />

</div>
<ol start="3" style="list-style-type: decimal">
<li><p>Si applica una eliminazione della doppia negazione.</p>
<pre><code>    !!  a  =  a
    !!! a  = !a</code></pre></li>
</ol>
<div class="figure">
<img src="imgs/formula_neg_elim.png" />

</div>
<ol start="4" style="list-style-type: decimal">
<li><p>Si distribuisce rispetto all'operatore <strong>OR</strong>:</p>
<pre><code>P | ( Q &amp; R )   ---&gt;   ( P | Q ) &amp; ( P | R )</code></pre>
<div class="figure">
<img src="imgs/formula_or_distrib.png" />

</div>
<p>Notare la ridondanza di alcuni nodi.</p></li>
<li><p>Alla fine si ottiene una formula a clausole, formate dall'ultimo strato da AND, il secondo strato da OR, e il terzo stato da NOTs.</p></li>
</ol>
<div class="figure">
<img src="imgs/cnf_structure.png" />

</div>
<p>I nodi ORs rappresentano indecisione sul valore di input, mentre le AND affermano decidibilita sull'input.</p>
<pre><code>   Esempio: A &amp; B  e&#39; reversibile
            L&#39;unico modo per avere **true** in output e che in input 
            sia **A** che **B** siano posti ad **true**</code></pre>
<p>{{IMMAGINE DI ESEMPIO}}</p>
</div>
<div id="why-cnf-form" class="slide section level1">
<h1>Why CNF Form?</h1>
<ul>
<li>La formula a CNF essendo formata da operatori <code>&amp;</code> presenti solo in &quot;cima&quot;, permette di dividere la verifica dell'intera soddisfacibilita' della formula nella verifica seperata della soddisfacibilita' delle singole clausole (Minore branching factor e parallelizzabile).</li>
</ul>
<p>Infatti l'operatore <code>&amp;</code> e' iniettivo quando si impone la condizione che l'output deve essere <code>vero</code>. Cio' permette di propagare il valore ai sotto-alberi che formano l'intera formula.</p>
</div>
<div id="dpll-explanation" class="slide section level1">
<h1>DPLL Explanation</h1>
<p>DPLL Procede nel seguente modo:</p>
<ol style="list-style-type: decimal">
<li><p>Analizza la formula e verifica la presenza di clausole unitarie, ovvero clausole il cui assegnamento e' forzato per fare in modo che la formula sia vera. Esempio:</p>
<pre><code>   A &amp; !B &amp; (C | D)   A deve necessariamente essere vera
                      B deve necessariamente essere falsa</code></pre></li>
<li><p>Trovate tutte le clausole unitarie si forza loro l'assegnamento corretto e si riduce l'albero di sintassi (UNIT PROPAGATION)</p>
<pre><code>   A &amp; !B &amp; (C | D)  --&gt;   C | D   con assegnamento A = 1, B = 0
   F &amp; 1             --&gt;   F
   G | 1             --&gt;   1</code></pre></li>
</ol>
<blockquote>
<p>Lo unit propagation costituisce la parte piu' complessa e il cuore di tutto l'algoritmo DPLL</p>
</blockquote>
<ol start="3" style="list-style-type: decimal">
<li><p>Gli operatori <strong>OR</strong> denotano indecisione sul valore dell'input. DPLL ora deve prendere una <strong>decisione</strong>. DPLL continua prendendo un letterale a caso, assegnando ad esso rispettivamente il valore <strong>true</strong> riduce l'AST con un <strong>unit-propagate</strong> e chiama ricorsivamente DPLL di nuovo. Se la chiamata ricorsiva porta ad insoddisfacimento alla formula, DPLL riassegna al letterale il valore <strong>false</strong> e riprova. (BACKTRACKING).</p></li>
<li><p>Prima o poi l'albero si sara' ridotto banalmente a:</p>
<pre><code>  1) true     sicuramente la formula e&#39; soddisfacibile
  2) false    sicuramente la formula e&#39; insoddisfacibile
  3) [-]      (formula vuota) insoddisfacibile</code></pre></li>
<li><p>Le chiamate ricorsive terminano non appena si raggiunge il soddisfacimento. La insoddisfacibilita' della formula invece porta DPLL a ritentare di nuovo.</p></li>
<li><p>Se DPLL termina tutti gli assegnamenti sui letterali possibili senza raggiungere il soddisfacimento della formula, allora la formula e' insoddisfacibile.</p></li>
</ol>
<p>{{ IMMAGINE }} {{ DEMO }}</p>
</div>
<div id="dpll-full-example" class="slide section level1">
<h1>DPLL Full Example</h1>
<h2 id="formula">Formula:</h2>
<pre><code>~A &amp; ( A | B | C )</code></pre>
<div class="figure">
<img src="imgs/dpll_full_run.gif" />

</div>
</div>
<div id="proving-theorems-with-dpll" class="slide section level1">
<h1>Proving Theorems with DPLL</h1>
<ul>
<li>Con DPLL e' possibile verificare la tautologia di una formula e di conseguenza dimostrare teoremi.</li>
<li>Ampio utilizzo nell'ambito <strong>EDA</strong> (Electronic Design Automation) per la sintetizzazzione e verifica di correttezza di circuiti logici.</li>
<li>Il modo per dimostrare un teorema e' prendere la formula originale aggiungere un nodo <strong>NOT</strong> ovvero negarla e valutare DPLL su di essa.</li>
</ul>
<p><strong>(<em>DIMOSTRAZIONE PER ASSURDO</em>)</strong></p>
<p>Se DPLL applicato su questa nuova formula porta sempre a insoddisfacimento, allora la formula e' sicuramente una tautologia, e quindi il teorema e' dimostrato. Se invece DPLL trova un soddisfacimento per questa formula allora sicuramente la tesi non e' valida. L'algoritmo in questo caso riporta l'assegnamento dei letterali cha hanno causato la non validita' della tesi.</p>
<p>{{IMMAGINE}} {{DEMO}}</p>
</div>
<div id="dpll-bf-comparison" class="slide section level1">
<h1>DPLL &amp; BF Comparison</h1>
<ul>
<li><p>Ovviamento il tempo di computazione rispetto a un algoritmo bruteforce e' <strong>DRASTICAMENTE</strong> migliorato.</p>
<pre><code>    Esempio di prima: &quot;a1 | a2 | .... | an&quot;</code></pre></li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">N: Numero letterali</th>
<th align="left">Tempo Computazione <strong>BF</strong></th>
<th align="left">Tempo Computazione <strong>DPLL</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">15</td>
<td align="left">6 secondi</td>
<td align="left">&lt; 1 milli-secondo</td>
</tr>
<tr class="even">
<td align="left">16</td>
<td align="left">12 secondi</td>
<td align="left">&lt; 1 milli-secondo</td>
</tr>
<tr class="odd">
<td align="left">17</td>
<td align="left">27 secondi</td>
<td align="left">&lt; 1 milli-secondo</td>
</tr>
<tr class="even">
<td align="left">18</td>
<td align="left">57 secondi</td>
<td align="left">&lt; 1 milli-secondo</td>
</tr>
<tr class="odd">
<td align="left">19</td>
<td align="left">121 secondi</td>
<td align="left">&lt; 1 milli-secondo</td>
</tr>
</tbody>
</table>
</div>
<div id="dpll-tp-curiosity" class="slide section level1">
<h1>DPLL &amp; TP: Curiosity</h1>
<ul>
<li><p>Per esempio questa formula casuale:</p>
<pre><code>  a == b ^ c -&gt; d | e &lt;-&gt; f ^ g &amp; h 
         | j | k &amp; l &gt; n | m &amp; o ^ q</code></pre></li>
</ul>
<p>stressa maggiormente il risolutore <code>DPLL</code>, infatti per arrivare ad una soluzione si ha rispettivamente che:</p>
<pre><code>     DPLL impiega :  14 milli-secondi
     TP impiega   : &lt; 1 milli-secondo</code></pre>
<ul>
<li><p>Sulla stessa formula <code>DPLL</code> e <code>TP</code> hanno tempi di computazione completamente diversi ( + di 1 ordine di grandezza).</p></li>
<li><p><strong>Se e solo se <em>ASSUMIAMO</em></strong> l'euristica che la formula non possa assumere <strong>SEMPRE il valore falso</strong>, allora possiamo concludere che se <code>TP</code> dimostra la validita' del teorema allora sicuramente si ha la garanzia dell'esistenza di una interpretazione in cui la formula assume il valore <code>true</code>. Se <code>TP</code> arriva all'insoddisfacimento (siccome abbiamo escluso caso formato da soli 0), possiamo comunque concludere che la formula fornisce almeno un valore <code>true</code>.</p></li>
<li><p>Se <code>DPLL</code> raggiunge un insoddisfacimento allora sicuramente la formula non e' una tautologia.</p></li>
<li><p>Se <code>DPLL</code> raggiunge un soddisfacimento allora, la formula potrebbe o no essere una tautologia.</p></li>
<li><p>Questa <strong>EURISTICA</strong> ci permette di ottimizzare l'algoritmo e di lanciare in parallelo (su 2 Thread diversi) sia <code>DPLL</code> sia <code>TP</code>, se <code>TP</code> arriva prima ad una soluzione ci permette di diminuire i tempi di computazione al <strong>MINIMO</strong> tra rispettivamente i tempi di computazione dei singoli algoritmi.</p></li>
<li><p>Questa <strong>EURISTICA</strong> per ovvie ragioni non e' ammissibile per formule composte da 1 singolo letterale, ma al crescere del numero di letterali che compongono la formula l'euristica tende sempre di piu' ad essere ammissibile.</p></li>
<li><p>L'uso di questa <strong>EURISTICA</strong> tuttavia non garantisce la completezza e la validita' della soluzione.</p></li>
</ul>
</div>
<div id="dpll-performance-analysis" class="slide section level1">
<h1>DPLL: Performance Analysis</h1>
<ul>
<li><strong>DPLL-unit-propagate</strong> costituisce la parte piu' corposa e il cuore dell'intero algoritmo. Nella nostra implementazione occupa circa il <code>95%</code> dell'<code>execution-time</code>. Nella nostra implementazione l'AST viene copiato e fisicamente ridotto, eliminando nodi nella fase di <code>unit-propagate</code>. Cio' garantisce una piu' facile implementazione di determinare che cosa sia una <strong>clausola unitaria</strong> ma comporta dei costi non trascurabili in performance.</li>
<li><p>Un <code>90%</code> di tempo di computazione speso in <code>unit-propagate</code> e' un valore tipico in qualunque implementazione DPLL.</p></li>
<li><p><strong>BAD!</strong>: <code>dpll-unit-propagate</code> non e' &quot;lavoro&quot; <strong>utile</strong> alla determinazione della soluzione. E' solo <strong>book-keeping</strong> che deve essere svolto per fare funzionare l'algoritmo, e' solo una ricostruzione dell'AST che mantiene equivalenza semantica, e non porta <code>DPLL</code> ad avvicinarsi ad una soluzione.</p></li>
</ul>
<p>Non si riesce a fare molto meglio di cosi'.</p>
</div>
<div id="dpll-improving-performance" class="slide section level1">
<h1>DPLL: Improving Performance</h1>
</div>
<div id="zchaff-state-of-the-art-dpll-derived-implementation" class="slide section level1">
<h1>zChaff: State of the Art DPLL-Derived Implementation</h1>
</div>
</body>
</html>
