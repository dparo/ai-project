
mices = [jerry]
cats = [tom]


// How to express the concatenation of list.
// is it based on evaluation/substitution or should it work like a c-macro???
animals = mices + cats




// Optimization generation, tree branch cutting off,
// What should happen when formulas do have side effect like in this
// case where we do print onto the screen...?

// Prolog just seems to do not care, and gives you an imperative
// style too to express this kind of stuff where really needed
// If used inside the expression the side effect may never be generated!
(# x @ mices { print(x) }) == (# x @ animals { mices[x], print(x) })


siblings[ [sally, erica], [ ... ] ]






// Questa formula puo' essere implementata dicendo che
// men e' un subset di people, e' tutti gli elementi di men
// devono essere in people per essere vera la formula
#x @ people { men[x] }

// Un atomo puo' essere visto come una lista vuota, oppure contenente solo il suo nome
// Una costante true o false puo' essere vista come una lista che e' sempre oppure mai
// il subset di un altra


// Formule prenesse
#x $y (x == y)

// `#` e `$` definiscono variabili -> `x` ed `y`
// se in forma prenessa l'operatore `$` non deve far altro che verificare la presenza del proprio atomo
// all'interno del corpo della formula
// se in forma prenessa l'operatore `#` fa la solita cosa che ha sempre fatto ed itera implicitamente
// come nel metodo bruteforce.


// NOTA: Attenzione all'AST. L'intera formula completa e' un unica espressione
// e { men[x] } non e' un espressione valida o comunque sensata
// nel contesto di appartenenza
#x @ people { men[x] }
