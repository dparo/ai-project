#if 0
  chmod +x ./ctfe-generator.c
  gcc -D_GNU_SOURCE -g3 -Wall -Wextra -Wno-unused-but-set-variable -Wno-unused-variable -I../common/  ctfe-generator.c -lm -o ./bin/ctfe-generator
  if [ $? -eq 0 ]; then
      ./bin/ctfe-generator
      exit $?
  fi
  exit $?
#endif

  void __fix_syntax__(void);

#define UTILS_C_IMPL
#include "utils.c"

#define PLATFORM_C_IMPL
#include "platform.c"

#define TOKENIZER_C_IMPL
#include "tokenizer.c"
  


void log_token (Token *token)
{
     printf("%.*s\tline_number=%d\tcolumn=%d\n", token->text_len, token->text, token->line_num, token->column);
}


inline static char*
convert_cfilename_to_define(char *name, i32 size)
{
     char *result = temp_storage_request(size, false);
     assert(result);
     i32 i = 0;
     for (; (name[i] != 0) && (i < size); i++) {
          char c = name[i];
          if (c <= 31) {
               assert_msg(0, "Weird ass string");
          }
          else if ( (c >= 0x21 && c <= 0x2F)
               || (c >= 0x3A && c <= 0x40)
               || (c >= 0x5B && c <= 0x5E)
               || (c >= 0x7B)
               || (c == '$')) {
               result[i] = '_';
          }
          else if ( (c >= 'a') && (c <= 'z')) {
               // upper case letter
               result[i] = c + 'A' - 'a';
          }
          else {
               result[i] = name[i];
          }
     }
     result[i] = 0;
     return result;
}

#define convert_cfilename_to_define_cstring(STR) convert_cfilename_to_define((STR), sizeof(STR) - 1)


void
ctfe_generate_requested_functions ( void )
{
     bool done = false;
     Tokenizer tknzr;
     Token token = Empty_Token;
     Token function_name = Empty_Token;
     
     tokenizer_init(&tknzr, "ctfe.c");

     char file_name[] = "__autogenerated__ctfe__.c";

     File_Handle fh = file_open(file_name, FILE_WRONLY | FILE_CREAT | FILE_TRUNC);
     assert(file_handle != -1);

     file_write(fh, "static bool call_all_ctfe_functions(void) {\n", sizeof("static void call_all_ctfe_functions(void) {\n") - 1);
     
     bool searching_for_function = true;    
     i32 nested_parens = 0;
     i32 nested_brackets = 0;
     i32 nested_braces = 0;
     
     
     // NOTE: Maybe better error handling because even the push_state can throw an error
     //       Maybe set a locked variable inside the tokenizer for critical stuff
     //       that will inevitably inject more complexity on the library side
     while (!done && get_next_token( &tknzr, &token)) {
          // NOTE: At every iteration the tokenizer error is cleared with the call to get_next_token
          
          if (nested_braces == 0 && nested_parens == 0 && nested_brackets == 0 ) {
               // Code to check that thingy
               if (compare_token_to(&token, "CTFE")) {
                    Token token = Empty_Token; // Avoids states leak by hiding the upper one
                    tokenizer_push_state(&tknzr);
                    if (get_next_token(&tknzr, &token) && token.type == TT_PUNCT_OPEN_PAREN) {
                         if (get_next_token(&tknzr, &function_name) && function_name.type == TT_IDENTIFIER ) {
                              Token temp1 = Empty_Token;
                              Token temp2 = Empty_Token;
                              if ( get_next_token(&tknzr, &temp1) && get_next_token(&tknzr, &temp2)) {
                                   if (temp1.type == TT_PUNCT_CLOSE_PAREN
                                       && temp2.type == TT_PUNCT_OPEN_BRACE ) {
                                        file_write(fh, "\t", sizeof("\t") - 1);
                                        file_write(fh, "if ( ", sizeof("if ( ")-1);
                                        file_write(fh, function_name.text, function_name.text_len);
                                        file_write(fh, "() == false )", sizeof("() == false )") - 1);
                                        file_write(fh, " { return false; }\n", sizeof(" { return false; }\n") - 1);
                                   }
                                   
                              }
                         }
                    }
                    tokenizer_pop_state(&tknzr);
               }
          }

          if (token.type == TT_PUNCT_OPEN_PAREN ) {
               ++nested_parens;
          }
          else if ( token.type == TT_PUNCT_CLOSE_PAREN ) {
               --nested_parens;
               if (searching_for_function == false && nested_parens == 0 ) {
                    Token next;
                    if (peek_next_token(&tknzr, &next) ) {
                         if (next.type == TT_PUNCT_OPEN_BRACE ) {
                              log_token( &function_name);
                              searching_for_function = true;
                         }
                    }
               }
          }
          else if(token.type == TT_PUNCT_OPEN_BRACKET ) {
               ++nested_brackets;
          }
          else if (token.type == TT_PUNCT_CLOSE_BRACKET) {
               --nested_brackets;
          }
          else if (token.type == TT_PUNCT_OPEN_BRACE) {
               ++nested_braces;
          }
          else if (token.type == TT_PUNCT_CLOSE_BRACE ) {
               --nested_braces;
         }
     
     }
     file_write(fh, "\treturn true;\n", sizeof("\treturn true;\n") - 1);
     file_write(fh, "}", sizeof("}") - 1);
     int close_result = file_close(fh);
     assert(close_result != -1 );
}


int
main(int argc, char **const argv)
{
     (void) argc, (void) argv;
     ctfe_generate_requested_functions();
}


